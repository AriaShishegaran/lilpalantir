Sub Question Query Engine[](#module-llama_index.query_engine.sub_question_query_engine "Permalink to this heading")
====================================================================================================================

*pydantic model* llama\_index.query\_engine.sub\_question\_query\_engine.SubQuestionAnswerPair[](#llama_index.query_engine.sub_question_query_engine.SubQuestionAnswerPair "Permalink to this definition")Pair of the sub question and optionally its answer (if its been answered yet).

Show JSON schema
```
{ "title": "SubQuestionAnswerPair", "description": "Pair of the sub question and optionally its answer (if its been answered yet).", "type": "object", "properties": { "sub\_q": { "$ref": "#/definitions/SubQuestion" }, "answer": { "title": "Answer", "type": "string" }, "sources": { "title": "Sources", "type": "array", "items": { "$ref": "#/definitions/NodeWithScore" } } }, "required": [ "sub\_q" ], "definitions": { "SubQuestion": { "title": "SubQuestion", "type": "object", "properties": { "sub\_question": { "title": "Sub Question", "type": "string" }, "tool\_name": { "title": "Tool Name", "type": "string" } }, "required": [ "sub\_question", "tool\_name" ] }, "ObjectType": { "title": "ObjectType", "description": "An enumeration.", "enum": [ "1", "2", "3", "4" ], "type": "string" }, "RelatedNodeInfo": { "title": "RelatedNodeInfo", "description": "Base component object to capture class names.", "type": "object", "properties": { "node\_id": { "title": "Node Id", "type": "string" }, "node\_type": { "$ref": "#/definitions/ObjectType" }, "metadata": { "title": "Metadata", "type": "object" }, "hash": { "title": "Hash", "type": "string" } }, "required": [ "node\_id" ] }, "BaseNode": { "title": "BaseNode", "description": "Base node Object.\n\nGeneric abstract interface for retrievable nodes", "type": "object", "properties": { "id\_": { "title": "Id ", "description": "Unique ID of the node.", "type": "string" }, "embedding": { "title": "Embedding", "description": "Embedding of the node.", "type": "array", "items": { "type": "number" } }, "extra\_info": { "title": "Extra Info", "description": "A flat dictionary of metadata fields", "type": "object" }, "excluded\_embed\_metadata\_keys": { "title": "Excluded Embed Metadata Keys", "description": "Metadata keys that are excluded from text for the embed model.", "type": "array", "items": { "type": "string" } }, "excluded\_llm\_metadata\_keys": { "title": "Excluded Llm Metadata Keys", "description": "Metadata keys that are excluded from text for the LLM.", "type": "array", "items": { "type": "string" } }, "relationships": { "title": "Relationships", "description": "A mapping of relationships to other node information.", "type": "object", "additionalProperties": { "anyOf": [ { "$ref": "#/definitions/RelatedNodeInfo" }, { "type": "array", "items": { "$ref": "#/definitions/RelatedNodeInfo" } } ] } }, "hash": { "title": "Hash", "description": "Hash of the node content.", "default": "", "type": "string" } } }, "NodeWithScore": { "title": "NodeWithScore", "description": "Base component object to capture class names.", "type": "object", "properties": { "node": { "$ref": "#/definitions/BaseNode" }, "score": { "title": "Score", "type": "number" } }, "required": [ "node" ] } }}
```


Fields* [`answer (Optional[str])`](#llama_index.query_engine.sub_question_query_engine.SubQuestionAnswerPair.answer "llama_index.query_engine.sub_question_query_engine.SubQuestionAnswerPair.answer")
* [`sources (List[llama\_index.schema.NodeWithScore])`](#llama_index.query_engine.sub_question_query_engine.SubQuestionAnswerPair.sources "llama_index.query_engine.sub_question_query_engine.SubQuestionAnswerPair.sources")
* [`sub\_q (llama\_index.question\_gen.types.SubQuestion)`](#llama_index.query_engine.sub_question_query_engine.SubQuestionAnswerPair.sub_q "llama_index.query_engine.sub_question_query_engine.SubQuestionAnswerPair.sub_q")
*field* answer*: Optional[str]* *= None*[](#llama_index.query_engine.sub_question_query_engine.SubQuestionAnswerPair.answer "Permalink to this definition")*field* sources*: List[[NodeWithScore](../../node.html#llama_index.schema.NodeWithScore "llama_index.schema.NodeWithScore")]* *[Optional]*[](#llama_index.query_engine.sub_question_query_engine.SubQuestionAnswerPair.sources "Permalink to this definition")*field* sub\_q*: SubQuestion* *[Required]*[](#llama_index.query_engine.sub_question_query_engine.SubQuestionAnswerPair.sub_q "Permalink to this definition")*classmethod* construct(*\_fields\_set: Optional[SetStr] = None*, *\*\*values: Any*) → Model[](#llama_index.query_engine.sub_question_query_engine.SubQuestionAnswerPair.construct "Permalink to this definition")Creates a new model setting \_\_dict\_\_ and \_\_fields\_set\_\_ from trusted or pre-validated data.Default values are respected, but no other validation is performed.Behaves as if Config.extra = ‘allow’ was set since it adds all passed values

copy(*\**, *include: Optional[Union[AbstractSetIntStr, MappingIntStrAny]] = None*, *exclude: Optional[Union[AbstractSetIntStr, MappingIntStrAny]] = None*, *update: Optional[DictStrAny] = None*, *deep: bool = False*) → Model[](#llama_index.query_engine.sub_question_query_engine.SubQuestionAnswerPair.copy "Permalink to this definition")Duplicate a model, optionally choose which fields to include, exclude and change.

Parameters* **include** – fields to include in new model
* **exclude** – fields to exclude from new model, as with values this takes precedence over include
* **update** – values to change/add in the new model. Note: the data is not validated before creatingthe new model: you should trust this data
* **deep** – set to True to make a deep copy of the model
Returnsnew model instance

dict(*\**, *include: Optional[Union[AbstractSetIntStr, MappingIntStrAny]] = None*, *exclude: Optional[Union[AbstractSetIntStr, MappingIntStrAny]] = None*, *by\_alias: bool = False*, *skip\_defaults: Optional[bool] = None*, *exclude\_unset: bool = False*, *exclude\_defaults: bool = False*, *exclude\_none: bool = False*) → DictStrAny[](#llama_index.query_engine.sub_question_query_engine.SubQuestionAnswerPair.dict "Permalink to this definition")Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.

*classmethod* from\_orm(*obj: Any*) → Model[](#llama_index.query_engine.sub_question_query_engine.SubQuestionAnswerPair.from_orm "Permalink to this definition")json(*\**, *include: Optional[Union[AbstractSetIntStr, MappingIntStrAny]] = None*, *exclude: Optional[Union[AbstractSetIntStr, MappingIntStrAny]] = None*, *by\_alias: bool = False*, *skip\_defaults: Optional[bool] = None*, *exclude\_unset: bool = False*, *exclude\_defaults: bool = False*, *exclude\_none: bool = False*, *encoder: Optional[Callable[[Any], Any]] = None*, *models\_as\_dict: bool = True*, *\*\*dumps\_kwargs: Any*) → unicode[](#llama_index.query_engine.sub_question_query_engine.SubQuestionAnswerPair.json "Permalink to this definition")Generate a JSON representation of the model, include and exclude arguments as per dict().

encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps().

*classmethod* parse\_file(*path: Union[str, Path]*, *\**, *content\_type: unicode = None*, *encoding: unicode = 'utf8'*, *proto: Protocol = None*, *allow\_pickle: bool = False*) → Model[](#llama_index.query_engine.sub_question_query_engine.SubQuestionAnswerPair.parse_file "Permalink to this definition")*classmethod* parse\_obj(*obj: Any*) → Model[](#llama_index.query_engine.sub_question_query_engine.SubQuestionAnswerPair.parse_obj "Permalink to this definition")*classmethod* parse\_raw(*b: Union[str, bytes]*, *\**, *content\_type: unicode = None*, *encoding: unicode = 'utf8'*, *proto: Protocol = None*, *allow\_pickle: bool = False*) → Model[](#llama_index.query_engine.sub_question_query_engine.SubQuestionAnswerPair.parse_raw "Permalink to this definition")*classmethod* schema(*by\_alias: bool = True*, *ref\_template: unicode = '#/definitions/{model}'*) → DictStrAny[](#llama_index.query_engine.sub_question_query_engine.SubQuestionAnswerPair.schema "Permalink to this definition")*classmethod* schema\_json(*\**, *by\_alias: bool = True*, *ref\_template: unicode = '#/definitions/{model}'*, *\*\*dumps\_kwargs: Any*) → unicode[](#llama_index.query_engine.sub_question_query_engine.SubQuestionAnswerPair.schema_json "Permalink to this definition")*classmethod* update\_forward\_refs(*\*\*localns: Any*) → None[](#llama_index.query_engine.sub_question_query_engine.SubQuestionAnswerPair.update_forward_refs "Permalink to this definition")Try to update ForwardRefs on fields based on this Model, globalns and localns.

*classmethod* validate(*value: Any*) → Model[](#llama_index.query_engine.sub_question_query_engine.SubQuestionAnswerPair.validate "Permalink to this definition")*class* llama\_index.query\_engine.sub\_question\_query\_engine.SubQuestionQueryEngine(*question\_gen: BaseQuestionGenerator*, *response\_synthesizer: [BaseSynthesizer](../response_synthesizer.html#llama_index.response_synthesizers.BaseSynthesizer "llama_index.response_synthesizers.base.BaseSynthesizer")*, *query\_engine\_tools: Sequence[QueryEngineTool]*, *callback\_manager: Optional[[CallbackManager](../../callbacks.html#llama_index.callbacks.CallbackManager "llama_index.callbacks.base.CallbackManager")] = None*, *verbose: bool = True*, *use\_async: bool = False*)[](#llama_index.query_engine.sub_question_query_engine.SubQuestionQueryEngine "Permalink to this definition")Sub question query engine.

A query engine that breaks down a complex query (e.g. compare and contrast) intomany sub questions and their target query engine for execution.After executing all sub questions, all responses are gathered and sent toresponse synthesizer to produce the final response.

Parameters* **question\_gen** (*BaseQuestionGenerator*) – A module for generating sub questionsgiven a complex question and tools.
* **response\_synthesizer** ([*BaseSynthesizer*](../response_synthesizer.html#llama_index.response_synthesizers.BaseSynthesizer "llama_index.response_synthesizers.BaseSynthesizer")) – A response synthesizer forgenerating the final response
* **query\_engine\_tools** (*Sequence**[**QueryEngineTool**]*) – Tools to answer thesub questions.
* **verbose** (*bool*) – whether to print intermediate questions and answers.Defaults to True
* **use\_async** (*bool*) – whether to execute the sub questions with asyncio.Defaults to True
get\_prompts() → Dict[str, [BasePromptTemplate](../../prompts.html#llama_index.prompts.base.BasePromptTemplate "llama_index.prompts.base.BasePromptTemplate")][](#llama_index.query_engine.sub_question_query_engine.SubQuestionQueryEngine.get_prompts "Permalink to this definition")Get a prompt.

update\_prompts(*prompts\_dict: Dict[str, [BasePromptTemplate](../../prompts.html#llama_index.prompts.base.BasePromptTemplate "llama_index.prompts.base.BasePromptTemplate")]*) → None[](#llama_index.query_engine.sub_question_query_engine.SubQuestionQueryEngine.update_prompts "Permalink to this definition")Update prompts.

Other prompts will remain in place.

